# .gitignore

```
.env auth.pem
```

# config.go

```go
// Copyright 2023 Gravitational, Inc // // Licensed under the Apache License, Version 2.0 (the "License"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package main // const ( // proxyAddr string = "teleport.hedge.foundation:443" // ) type Config struct { proxyAddr string discordwebhookURL string watcherList string }
```

# discord.go

```go
package main import ( "fmt" "strings" "time" "github.com/gravitational/teleport/api/types" "github.com/gtuk/discordwebhook" ) func (d *discordClient) sendWebhookNotification(message discordwebhook.Message) error { // Send the webhook err := discordwebhook.SendMessage(d.url, message) if err != nil { return err } return nil } func ptrString(s string) *string { return &s } func ptrBool(b bool) *bool { return &b } func (d *discordClient) handleNewAccessRequest(r types.AccessRequest) error { fields := []discordwebhook.Field{ { Name: ptrString("Request ID"), Value: ptrString(r.GetName()), Inline: ptrBool(false), }, { Name: ptrString("User"), Value: ptrString(r.GetUser()), Inline: ptrBool(true), }, { Name: ptrString("Roles"), Value: ptrString(strings.Join(r.GetRoles(), ", ")), Inline: ptrBool(true), }, { Name: ptrString("Session TTL"), Value: ptrString(r.GetSessionTLL().Sub(r.GetCreationTime()).Round(time.Second).String()), Inline: ptrBool(true), }, } if r.GetRequestReason() != "" { fields = append(fields, discordwebhook.Field{ Name: ptrString("Request Reason"), Value: ptrString(r.GetRequestReason()), Inline: ptrBool(false), }) } embed := discordwebhook.Embed{ Title: ptrString("New Access Request"), Description: ptrString(fmt.Sprintf("Approve request by running command %s: \`\`\`tctl requests approve %s\`\`\`", d.cfg.watcherList, r.GetName())), Color: ptrString("3093206"), Fields: &fields, } message := discordwebhook.Message{ Embeds: &[]discordwebhook.Embed{embed}, } err := d.sendWebhookNotification(message) if err != nil { fmt.Printf("Error sending notification: %v\n", err) return err } fmt.Println("Notification sent successfully!") return nil } func (d *discordClient) handleApproveAccessRequest(r types.AccessRequest) error { embed := discordwebhook.Embed{ Title: ptrString("Access Request Approved"), Color: ptrString("2021216"), Fields: &[]discordwebhook.Field{ { Name: ptrString("Request ID"), Value: ptrString(r.GetName()), Inline: ptrBool(false), }, { Name: ptrString("User"), Value: ptrString(r.GetUser()), Inline: ptrBool(true), }, { Name: ptrString("Roles"), Value: ptrString(strings.Join(r.GetRoles(), ", ")), Inline: ptrBool(true), }, }, } message := discordwebhook.Message{ Embeds: &[]discordwebhook.Embed{embed}, } err := d.sendWebhookNotification(message) if err != nil { fmt.Printf("Error sending notification: %v\n", err) return err } fmt.Println("Notification sent successfully!") return nil } func (d *discordClient) handleDenyAccessRequest(r types.AccessRequest) error { embed := discordwebhook.Embed{ Title: ptrString("Access Request Denied"), Color: ptrString("15158332"), Fields: &[]discordwebhook.Field{ { Name: ptrString("Request ID"), Value: ptrString(r.GetName()), Inline: ptrBool(false), }, { Name: ptrString("User"), Value: ptrString(r.GetUser()), Inline: ptrBool(true), }, { Name: ptrString("Roles"), Value: ptrString(strings.Join(r.GetRoles(), ", ")), Inline: ptrBool(true), }, { Name: ptrString("Reason"), Value: ptrString(r.GetResolveReason()), Inline: ptrBool(false), }, }, } message := discordwebhook.Message{ Embeds: &[]discordwebhook.Embed{embed}, } err := d.sendWebhookNotification(message) if err != nil { fmt.Printf("Error sending notification: %v\n", err) return err } fmt.Println("Notification sent successfully!") return nil }
```

# go.mod

```mod
module teleport-sheets go 1.21 require ( github.com/bwmarrin/discordgo v0.28.1 github.com/gravitational/teleport/api v0.0.0-20240220221413-126de63e7e40 github.com/gravitational/trace v1.3.1 github.com/gtuk/discordwebhook v1.2.0 github.com/joho/godotenv v1.5.1 google.golang.org/grpc v1.61.1 ) require ( cloud.google.com/go/compute/metadata v0.2.3 // indirect github.com/beevik/etree v1.2.0 // indirect github.com/cenkalti/backoff/v4 v4.2.1 // indirect github.com/coreos/go-semver v0.3.1 // indirect github.com/felixge/httpsnoop v1.0.4 // indirect github.com/go-logr/logr v1.4.1 // indirect github.com/go-logr/stdr v1.2.2 // indirect github.com/go-piv/piv-go v1.11.0 // indirect github.com/gobwas/httphead v0.1.0 // indirect github.com/gobwas/pool v0.2.1 // indirect github.com/gobwas/ws v1.3.2 // indirect github.com/gogo/protobuf v1.3.2 // indirect github.com/golang/protobuf v1.5.3 // indirect github.com/google/go-cmp v0.6.0 // indirect github.com/google/uuid v1.6.0 // indirect github.com/gorilla/websocket v1.4.2 // indirect github.com/grpc-ecosystem/grpc-gateway/v2 v2.19.0 // indirect github.com/jonboulle/clockwork v0.4.0 // indirect github.com/mattermost/xml-roundtrip-validator v0.1.0 // indirect github.com/russellhaering/gosaml2 v0.9.1 // indirect github.com/russellhaering/goxmldsig v1.4.0 // indirect github.com/sirupsen/logrus v1.9.3 // indirect go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc v0.47.0 // indirect go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.47.0 // indirect go.opentelemetry.io/otel v1.22.0 // indirect go.opentelemetry.io/otel/exporters/otlp/otlptrace v1.22.0 // indirect go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc v1.22.0 // indirect go.opentelemetry.io/otel/metric v1.22.0 // indirect go.opentelemetry.io/otel/sdk v1.22.0 // indirect go.opentelemetry.io/otel/trace v1.22.0 // indirect go.opentelemetry.io/proto/otlp v1.1.0 // indirect golang.org/x/crypto v0.31.0 // indirect golang.org/x/exp v0.0.0-20230811145659-89c5cff77bcb // indirect golang.org/x/net v0.33.0 // indirect golang.org/x/sys v0.28.0 // indirect golang.org/x/term v0.27.0 // indirect golang.org/x/text v0.21.0 // indirect google.golang.org/genproto/googleapis/api v0.0.0-20240102182953-50ed04b92917 // indirect google.golang.org/genproto/googleapis/rpc v0.0.0-20240102182953-50ed04b92917 // indirect google.golang.org/protobuf v1.33.0 // indirect gopkg.in/yaml.v2 v2.4.0 // indirect )
```

# main.go

```go
// Copyright 2023 Gravitational, Inc // // Licensed under the Apache License, Version 2.0 (the "License"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package main import ( "context" "os" "google.golang.org/grpc" "github.com/gravitational/teleport/api/client" "github.com/joho/godotenv" ) func main() { // Load environment variables err := godotenv.Load() if err != nil { panic(err) } cfg := Config{ proxyAddr: os.Getenv("PROXY_ADDR"), discordwebhookURL: os.Getenv("DISCORD_WEBHOOK_URL"), watcherList: os.Getenv("WATCHER_LIST"), } // Create a new Teleport client ctx := context.Background() creds := client.LoadIdentityFile("auth.pem") teleport, err := client.New(ctx, client.Config{ Addrs: []string{cfg.proxyAddr}, Credentials: []client.Credentials{creds}, DialOpts: []grpc.DialOption{ grpc.WithReturnConnectionError(), }, }) if err != nil { panic(err) } defer teleport.Close() // Create a new Discord client discordClient := discordClient{ url: cfg.discordwebhookURL, cfg: cfg, } // Create a new AccessRequestPlugin plugin := AccessRequestPlugin{ TeleportClient: teleport, EventHandler: &discordClient, } if err := plugin.Run(); err != nil { panic(err) } }
```

# plugin.go

```go
// Copyright 2023 Gravitational, Inc // // Licensed under the Apache License, Version 2.0 (the "License"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package main import ( "context" "github.com/gravitational/teleport/api/client" "github.com/gravitational/teleport/api/types" ) type AccessRequestPlugin struct { TeleportClient *client.Client EventHandler interface { HandleEvent(ctx context.Context, event types.Event) error } } type discordClient struct { url string cfg Config }
```

# README.md

```md
# Minimal Access Request plugin example This is a minimal working example of an Access Request plugin. To use it, follow the setup steps we describe in the [Teleport documentation](http://goteleport.com/docs/api/access-plugin/).
```

# watcherjob.go

```go
// Copyright 2023 Gravitational, Inc // // Licensed under the Apache License, Version 2.0 (the "License"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package main import ( "context" "fmt" "github.com/bwmarrin/discordgo" "github.com/gravitational/trace" "github.com/gravitational/teleport/api/types" ) func SendDiscordNotification(token string, channelID string, message string) error { // Create a new Discord session using the provided bot token // Note: token should include "Bot " prefix if it's a bot token dg, err := discordgo.New(token) if err != nil { return fmt.Errorf("error creating Discord session: %v", err) } defer dg.Close() // Send the message _, err = dg.ChannelMessageSend(channelID, message) if err != nil { return fmt.Errorf("error sending message: %v", err) } return nil } func (d *discordClient) HandleEvent(ctx context.Context, event types.Event) error { if event.Resource == nil { return nil } if _, ok := event.Resource.(*types.WatchStatusV1); ok { fmt.Println("Successfully started listening for Access Requests...") return nil } r, ok := event.Resource.(types.AccessRequest) if !ok { fmt.Printf("Unknown (%v) event received, skipping.\n", event.Resource) return nil } switch r.GetState() { case types.RequestState_PENDING: if err := d.handleNewAccessRequest(r); err != nil { return err } case types.RequestState_APPROVED: if err := d.handleApproveAccessRequest(r); err != nil { return err } case types.RequestState_DENIED: if err := d.handleDenyAccessRequest(r); err != nil { return err } } return nil } func (p *AccessRequestPlugin) Run() error { ctx := context.Background() watch, err := p.TeleportClient.NewWatcher(ctx, types.Watch{ Kinds: []types.WatchKind{ types.WatchKind{Kind: types.KindAccessRequest}, }, }) if err != nil { return trace.Wrap(err) } defer watch.Close() fmt.Println("Starting the watcher job") for { select { case e := <-watch.Events(): if err := p.EventHandler.HandleEvent(ctx, e); err != nil { return trace.Wrap(err) } case <-watch.Done(): fmt.Println("The watcher job is finished") return nil } } }
```

